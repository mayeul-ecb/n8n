{"version":3,"file":"tracing.js","sources":["../../src/tracing.ts"],"sourcesContent":["import { getActiveSpan, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, startInactiveSpan } from '@sentry/browser';\nimport type { Span } from '@sentry/core';\nimport { debug, timestampInSeconds } from '@sentry/core';\nimport { DEFAULT_HOOKS } from './constants';\nimport { DEBUG_BUILD } from './debug-build';\nimport type { Hook, Operation, TracingOptions, ViewModel, Vue } from './types';\nimport { formatComponentName } from './vendor/components';\n\nconst VUE_OP = 'ui.vue';\n\ntype Mixins = Parameters<Vue['mixin']>[0];\n\ninterface VueSentry extends ViewModel {\n  readonly $root: VueSentry;\n  $_sentryComponentSpans?: {\n    [key: string]: Span | undefined;\n  };\n  $_sentryRootComponentSpan?: Span;\n  $_sentryRootComponentSpanTimer?: ReturnType<typeof setTimeout>;\n}\n\n// Mappings from operation to corresponding lifecycle hook.\nconst HOOKS: { [key in Operation]: Hook[] } = {\n  activate: ['activated', 'deactivated'],\n  create: ['beforeCreate', 'created'],\n  // Vue 3\n  unmount: ['beforeUnmount', 'unmounted'],\n  // Vue 2\n  destroy: ['beforeDestroy', 'destroyed'],\n  mount: ['beforeMount', 'mounted'],\n  update: ['beforeUpdate', 'updated'],\n};\n\n/** End the top-level component span and activity with a debounce configured using `timeout` option */\nfunction maybeEndRootComponentSpan(vm: VueSentry, timestamp: number, timeout: number): void {\n  if (vm.$_sentryRootComponentSpanTimer) {\n    clearTimeout(vm.$_sentryRootComponentSpanTimer);\n  }\n\n  vm.$_sentryRootComponentSpanTimer = setTimeout(() => {\n    if (vm.$root?.$_sentryRootComponentSpan) {\n      vm.$root.$_sentryRootComponentSpan.end(timestamp);\n      vm.$root.$_sentryRootComponentSpan = undefined;\n    }\n  }, timeout);\n}\n\n/** Find if the current component exists in the provided `TracingOptions.trackComponents` array option. */\nexport function findTrackComponent(trackComponents: string[], formattedName: string): boolean {\n  function extractComponentName(name: string): string {\n    return name.replace(/^<([^\\s]*)>(?: at [^\\s]*)?$/, '$1');\n  }\n\n  const isMatched = trackComponents.some(compo => {\n    return extractComponentName(formattedName) === extractComponentName(compo);\n  });\n\n  return isMatched;\n}\n\nexport const createTracingMixins = (options: Partial<TracingOptions> = {}): Mixins => {\n  const hooks = (options.hooks || [])\n    .concat(DEFAULT_HOOKS)\n    // Removing potential duplicates\n    .filter((value, index, self) => self.indexOf(value) === index);\n\n  const mixins: Mixins = {};\n\n  const rootComponentSpanFinalTimeout = options.timeout || 2000;\n\n  for (const operation of hooks) {\n    // Retrieve corresponding hooks from Vue lifecycle.\n    // eg. mount => ['beforeMount', 'mounted']\n    const internalHooks = HOOKS[operation];\n    if (!internalHooks) {\n      DEBUG_BUILD && debug.warn(`Unknown hook: ${operation}`);\n      continue;\n    }\n\n    for (const internalHook of internalHooks) {\n      mixins[internalHook] = function (this: VueSentry) {\n        const isRootComponent = this.$root === this;\n\n        // 1. Root Component span creation\n        if (isRootComponent) {\n          this.$_sentryRootComponentSpan =\n            this.$_sentryRootComponentSpan ||\n            startInactiveSpan({\n              name: 'Application Render',\n              op: `${VUE_OP}.render`,\n              attributes: {\n                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.vue',\n              },\n              onlyIfParent: true,\n            });\n\n          // call debounced end function once directly, just in case no child components call it\n          maybeEndRootComponentSpan(this, timestampInSeconds(), rootComponentSpanFinalTimeout);\n        }\n\n        // 2. Component tracking filter\n        const componentName = formatComponentName(this, false);\n\n        const shouldTrack =\n          isRootComponent || // We always want to track the root component\n          (Array.isArray(options.trackComponents)\n            ? findTrackComponent(options.trackComponents, componentName)\n            : options.trackComponents);\n\n        // We always want to track root component\n        if (!shouldTrack) {\n          // even if we don't track `this` component, we still want to end the root span eventually\n          maybeEndRootComponentSpan(this, timestampInSeconds(), rootComponentSpanFinalTimeout);\n          return;\n        }\n\n        this.$_sentryComponentSpans = this.$_sentryComponentSpans || {};\n\n        // 3. Span lifecycle management based on the hook type\n        const isBeforeHook = internalHook === internalHooks[0];\n        const activeSpan = this.$root?.$_sentryRootComponentSpan || getActiveSpan();\n\n        if (isBeforeHook) {\n          // Starting a new span in the \"before\" hook\n          if (activeSpan) {\n            // Cancel any existing span for this operation (safety measure)\n            // We're actually not sure if it will ever be the case that cleanup hooks were not called.\n            // However, we had users report that spans didn't end, so we end the span before\n            // starting a new one, just to be sure.\n            const oldSpan = this.$_sentryComponentSpans[operation];\n            if (oldSpan) {\n              oldSpan.end();\n            }\n\n            this.$_sentryComponentSpans[operation] = startInactiveSpan({\n              name: `Vue ${componentName}`,\n              op: `${VUE_OP}.${operation}`,\n              attributes: {\n                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.vue',\n              },\n              // UI spans should only be created if there is an active root span (transaction)\n              onlyIfParent: true,\n            });\n          }\n        } else {\n          // The span should already be added via the first handler call (in the 'before' hook)\n          const span = this.$_sentryComponentSpans[operation];\n          // The before hook did not start the tracking span, so the span was not added.\n          // This is probably because it happened before there is an active transaction\n          if (!span) return; // Skip if no span was created in the \"before\" hook\n          span.end();\n\n          // For any \"after\" hook, also schedule the root component span to end\n          maybeEndRootComponentSpan(this, timestampInSeconds(), rootComponentSpanFinalTimeout);\n        }\n      };\n    }\n  }\n\n  return mixins;\n};\n"],"names":[],"mappings":"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"}