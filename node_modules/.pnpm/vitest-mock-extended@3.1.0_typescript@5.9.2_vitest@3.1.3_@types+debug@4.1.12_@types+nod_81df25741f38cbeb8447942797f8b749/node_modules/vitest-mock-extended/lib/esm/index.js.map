{"version":3,"file":"index.js","sources":["../../src/Matchers.ts","../../src/CalledWithFn.ts","../../src/Mock.ts"],"sourcesContent":["type MatcherFn<T> = (actualValue: T) => boolean\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ninterface MatcherLike<T> {\n  asymmetricMatch(other: unknown): boolean\n  toString(): string\n  getExpectedType?(): string\n  toAsymmetricMatcher?(): string\n}\n\n// needs to be a class so we can instanceof\nclass Matcher<T> implements MatcherLike<T> {\n  $$typeof: symbol\n  inverse?: boolean\n\n  constructor(\n    readonly asymmetricMatch: MatcherFn<T>,\n    private readonly description: string,\n  ) {\n    this.$$typeof = Symbol.for('vi.asymmetricMatcher')\n  }\n\n  toString() {\n    return this.description\n  }\n\n  toAsymmetricMatcher() {\n    return this.description\n  }\n\n  getExpectedType() {\n    return 'undefined'\n  }\n}\n\nclass CaptorMatcher<T> {\n  $$typeof: symbol\n  public readonly asymmetricMatch: MatcherFn<T>\n  public readonly value!: T\n  public readonly values: T[] = []\n  constructor() {\n    this.$$typeof = Symbol.for('vi.asymmetricMatcher')\n\n    this.asymmetricMatch = (actualValue: T) => {\n      // @ts-expect-error value should be read-only but we need to set it\n      this.value = actualValue\n      this.values.push(actualValue)\n      return true\n    }\n  }\n\n  getExpectedType() {\n    return 'Object'\n  }\n\n  toString() {\n    return 'captor'\n  }\n\n  toAsymmetricMatcher() {\n    return 'captor'\n  }\n}\n\ninterface MatcherCreator<T, E = T> {\n  (expectedValue?: E): Matcher<T>\n}\n\ntype MatchersOrLiterals<Y extends unknown[]> = { [K in keyof Y]: MatcherLike<Y[K]> | Y[K] }\n\nconst any: MatcherCreator<unknown> = () => new Matcher(() => true, 'any()')\nconst anyBoolean: MatcherCreator<boolean> = () => new Matcher((actualValue: boolean) => typeof actualValue === 'boolean', 'anyBoolean()')\nconst anyNumber: MatcherCreator<number> = () =>\n  new Matcher((actualValue) => typeof actualValue === 'number' && !isNaN(actualValue), 'anyNumber()')\nconst anyString: MatcherCreator<string> = () => new Matcher((actualValue: string) => typeof actualValue === 'string', 'anyString()')\nconst anyFunction: MatcherCreator<CallableFunction> = () =>\n  new Matcher((actualValue: CallableFunction) => typeof actualValue === 'function', 'anyFunction()')\nconst anySymbol: MatcherCreator<symbol> = () => new Matcher((actualValue) => typeof actualValue === 'symbol', 'anySymbol()')\nconst anyObject: MatcherCreator<unknown> = () =>\n  new Matcher((actualValue) => typeof actualValue === 'object' && actualValue !== null, 'anyObject()')\n\nconst anyArray: MatcherCreator<unknown[]> = () => new Matcher((actualValue) => Array.isArray(actualValue), 'anyArray()')\nconst anyMap: MatcherCreator<Map<unknown, unknown>> = () => new Matcher((actualValue) => actualValue instanceof Map, 'anyMap()')\nconst anySet: MatcherCreator<Set<unknown>> = () => new Matcher((actualValue) => actualValue instanceof Set, 'anySet()')\nconst isA: MatcherCreator<any> = (clazz) => new Matcher((actualValue) => actualValue instanceof clazz, 'isA()')\n\nconst arrayIncludes: MatcherCreator<unknown[], unknown> = (arrayVal) =>\n  new Matcher((actualValue) => Array.isArray(actualValue) && actualValue.includes(arrayVal), 'arrayIncludes()')\nconst setHas: MatcherCreator<Set<unknown>, unknown> = (arrayVal) =>\n  new Matcher((actualValue) => anySet().asymmetricMatch(actualValue) && actualValue.has(arrayVal), 'setHas()')\nconst mapHas: MatcherCreator<Map<unknown, unknown>, unknown> = (mapVal) =>\n  new Matcher((actualValue) => anyMap().asymmetricMatch(actualValue) && actualValue.has(mapVal), 'mapHas()')\nconst objectContainsKey: MatcherCreator<Record<string, unknown>, string> = (key) =>\n  new Matcher((actualValue) => anyObject().asymmetricMatch(actualValue) && actualValue[key!] !== undefined, 'objectContainsKey()')\nconst objectContainsValue: MatcherCreator<Record<string, unknown> | ArrayLike<unknown>> = (value) =>\n  new Matcher(\n    (actualValue) => anyObject().asymmetricMatch(actualValue) && Object.values(actualValue).includes(value),\n    'objectContainsValue()',\n  )\n\nconst notNull: MatcherCreator<unknown> = () => new Matcher((actualValue) => actualValue !== null, 'notNull()')\nconst notUndefined: MatcherCreator<unknown> = () => new Matcher((actualValue) => actualValue !== undefined, 'notUndefined()')\nconst notEmpty: MatcherCreator<unknown> = () =>\n  new Matcher((actualValue) => actualValue !== null && actualValue !== undefined && actualValue !== '', 'notEmpty()')\n\nconst captor = <T>() => new CaptorMatcher<T>()\nconst matches = <T>(matcher: MatcherFn<T>) => new Matcher(matcher, 'matches()')\n\nexport {\n  Matcher,\n  CaptorMatcher,\n  any,\n  anyBoolean,\n  anyNumber,\n  anyString,\n  anyFunction,\n  anySymbol,\n  anyObject,\n  anyArray,\n  anyMap,\n  anySet,\n  isA,\n  arrayIncludes,\n  setHas,\n  mapHas,\n  objectContainsKey,\n  objectContainsValue,\n  notNull,\n  notUndefined,\n  notEmpty,\n  captor,\n  matches,\n}\nexport type { MatcherFn, MatchersOrLiterals, MatcherCreator, MatcherLike }\n","import { CalledWithMock } from './Mock'\nimport { Matcher, MatchersOrLiterals } from './Matchers'\nimport { FallbackImplementation } from './types'\nimport { vi, Mock } from 'vitest'\n\ninterface CalledWithStackItem<T, Y extends any[]> {\n  args: MatchersOrLiterals<Y>\n  calledWithFn: Mock<FallbackImplementation<Y, T>>\n}\n\ninterface VitestAsymmetricMatcher {\n  asymmetricMatch(...args: any[]): boolean\n}\n\nfunction isVitestAsymmetricMatcher(obj: any): obj is VitestAsymmetricMatcher {\n  return !!obj && typeof obj === 'object'\n    && 'asymmetricMatch' in obj\n    && typeof obj.asymmetricMatch === 'function'\n}\n\nconst checkCalledWith = <T, Y extends any[]>(\n  calledWithStack: CalledWithStackItem<T, Y>[],\n  actualArgs: Y,\n  fallbackMockImplementation?: FallbackImplementation<Y, T>,\n): T => {\n  const calledWithInstance = calledWithStack.find((instance) =>\n    instance.args.every((matcher, i) => {\n      if (matcher instanceof Matcher) {\n        return matcher.asymmetricMatch(actualArgs[i])\n      }\n\n      if (isVitestAsymmetricMatcher(matcher)) {\n        return matcher.asymmetricMatch(actualArgs[i])\n      }\n\n      return actualArgs[i] === matcher\n    }),\n  )\n\n  // @ts-ignore\n  return calledWithInstance\n    ? calledWithInstance.calledWithFn(...actualArgs)\n    : fallbackMockImplementation && fallbackMockImplementation(...actualArgs)\n}\n\ntype CalledWithFnArgs<Y extends any[], T> = { fallbackMockImplementation?: FallbackImplementation<Y, T> }\n\nconst calledWithFn = <T, Y extends any[]>({ fallbackMockImplementation }: CalledWithFnArgs<Y, T> = {}): CalledWithMock<T, Y> => {\n  const fn: Mock<FallbackImplementation<Y, T>> = fallbackMockImplementation ? vi.fn(fallbackMockImplementation) : vi.fn()\n  let calledWithStack: CalledWithStackItem<T, Y>[] = []\n\n    ; (fn as CalledWithMock<T, Y>).calledWith = (...args) => {\n      // We create new function to delegate any interactions (mockReturnValue etc.) to for this set of args.\n      // If that set of args is matched, we just call that vi.fn() for the result.\n      const calledWithFn: Mock<FallbackImplementation<Y, T>> = fallbackMockImplementation ? vi.fn(fallbackMockImplementation) : vi.fn()\n      const mockImplementation = fn.getMockImplementation()\n      if (\n        !mockImplementation ||\n        fn.getMockImplementation()?.name === 'implementation' ||\n        mockImplementation === fallbackMockImplementation\n      ) {\n        // Our original function gets a mock implementation which handles the matching\n        fn.mockImplementation((...args: Y) => checkCalledWith(calledWithStack, args, fallbackMockImplementation))\n        calledWithStack = []\n      }\n      calledWithStack.unshift({ args, calledWithFn })\n\n      return calledWithFn\n    }\n\n  return fn as CalledWithMock<T, Y>\n}\n\nexport { calledWithFn }\n","import { calledWithFn } from './CalledWithFn'\nimport { MatchersOrLiterals } from './Matchers'\nimport { FallbackImplementation } from './types'\nimport { DeepPartial } from 'ts-essentials'\nimport { Mock, vi } from 'vitest'\n\ntype ProxiedProperty = string | number | symbol\n\ninterface GlobalConfig {\n  // ignoreProps is required when we don't want to return anything for a mock (for example, when mocking a promise).\n  ignoreProps?: ProxiedProperty[]\n}\n\nconst DEFAULT_CONFIG: GlobalConfig = {\n  ignoreProps: ['then'],\n}\n\nlet GLOBAL_CONFIG = DEFAULT_CONFIG\n\nconst VitestMockExtended = {\n  DEFAULT_CONFIG,\n  configure: (config: GlobalConfig) => {\n    // Shallow merge so they can override anything they want.\n    GLOBAL_CONFIG = { ...DEFAULT_CONFIG, ...config }\n  },\n  resetConfig: () => {\n    GLOBAL_CONFIG = DEFAULT_CONFIG\n  },\n}\n\ninterface CalledWithMock<T, Y extends any[]> extends Mock<FallbackImplementation<Y, T>> {\n  calledWith: (...args: Y | MatchersOrLiterals<Y>) => Mock<FallbackImplementation<Y, T>>\n}\n\ntype _MockProxy<T> = {\n  [K in keyof T]: T[K] extends (...args: infer A) => infer B ? T[K] & CalledWithMock<B, A> : T[K]\n}\n\ntype MockProxy<T> = _MockProxy<T> & T\n\ntype _DeepMockProxy<T> = {\n  // This supports deep mocks in the else branch\n  [K in keyof T]: T[K] extends (...args: infer A) => infer B ? T[K] & CalledWithMock<B, A> : T[K] & _DeepMockProxy<T[K]>\n}\n\n// we intersect with T here instead of on the mapped type above to\n// prevent immediate type resolution on a recursive type, this will\n// help to improve performance for deeply nested recursive mocking\n// at the same time, this intersection preserves private properties\ntype DeepMockProxy<T> = _DeepMockProxy<T> & T\n\ntype _DeepMockProxyWithFuncPropSupport<T> = {\n  // This supports deep mocks in the else branch\n  [K in keyof T]: T[K] extends (...args: infer A) => infer B ? CalledWithMock<B, A> & DeepMockProxy<T[K]> : DeepMockProxy<T[K]>\n}\n\ntype DeepMockProxyWithFuncPropSupport<T> = _DeepMockProxyWithFuncPropSupport<T> & T\n\ninterface MockOpts {\n  deep?: boolean\n  useActualToJSON?: boolean\n  fallbackMockImplementation?: (...args: any[]) => any\n}\n\nconst mockClear = (mock: MockProxy<any>) => {\n  for (const key of Object.keys(mock)) {\n    const value = mock[key]\n    if (value === null || value === undefined) {\n      continue\n    }\n\n    if (value._isMockObject) {\n      mockClear(value)\n    }\n\n    if (value._isMockFunction && 'mockClear' in value) {\n      value.mockClear()\n    }\n  }\n\n  // This is a catch for if they pass in a vi.fn()\n  if (!mock._isMockObject) {\n    return mock.mockClear()\n  }\n}\n\nconst mockReset = (mock: MockProxy<any>) => {\n  for (const key of Object.keys(mock)) {\n    if (mock[key] === null || mock[key] === undefined) {\n      continue\n    }\n\n    if (mock[key]._isMockObject) {\n      mockReset(mock[key])\n    }\n    if (mock[key]._isMockFunction) {\n      mock[key].mockReset()\n    }\n  }\n\n  // This is a catch for if they pass in a vi.fn()\n  // Worst case, we will create a vi.fn() (since this is a proxy)\n  // below in the get and call mockReset on it\n  if (!mock._isMockObject) {\n    return mock.mockReset()\n  }\n}\n\nfunction mockDeep<T>(\n  opts: {\n    funcPropSupport?: true\n    fallbackMockImplementation?: MockOpts['fallbackMockImplementation']\n  },\n  mockImplementation?: DeepPartial<T>,\n): DeepMockProxyWithFuncPropSupport<T>\nfunction mockDeep<T>(mockImplementation?: DeepPartial<T>): DeepMockProxy<T>\nfunction mockDeep(arg1: any, arg2?: any) {\n  const [opts, mockImplementation] =\n    typeof arg1 === 'object'\n      && (typeof arg1.fallbackMockImplementation === 'function' || arg1.funcPropSupport === true)\n      ? [arg1, arg2]\n      : [{}, arg1]\n  return mock(mockImplementation, { deep: true, fallbackMockImplementation: opts.fallbackMockImplementation })\n}\n\nconst overrideMockImp = (obj: DeepPartial<any>, opts?: MockOpts) => {\n  const proxy = new Proxy<MockProxy<any>>(obj, handler(opts))\n  for (const name of Object.keys(obj)) {\n    if (typeof obj[name] === 'object' && obj[name] !== null) {\n      proxy[name] = overrideMockImp(obj[name], opts)\n    } else {\n      proxy[name] = obj[name]\n    }\n  }\n\n  return proxy\n}\n\nconst handler = (opts?: MockOpts) => ({\n  ownKeys(target: MockProxy<any>) {\n    return Reflect.ownKeys(target)\n  },\n\n  set: (obj: MockProxy<any>, property: ProxiedProperty, value: any) => {\n    obj[property] = value\n    return true\n  },\n\n  get: (obj: MockProxy<any>, property: ProxiedProperty) => {\n    if (!(property in obj)) {\n      if (property === '_isMockObject' || property === '_isMockFunction') {\n        return undefined\n      }\n\n      if (GLOBAL_CONFIG.ignoreProps?.includes(property)) {\n        return undefined\n      }\n      // Jest's internal equality checking does some wierd stuff to check for iterable equality\n      if (property === Symbol.iterator) {\n        return obj[property]\n      }\n\n      if (opts?.useActualToJSON && property === 'toJSON') {\n        return JSON.stringify(obj)\n      }\n\n      // So this calls check here is totally not ideal - jest internally does a\n      // check to see if this is a spy - which we want to say no to, but blindly returning\n      // an proxy for calls results in the spy check returning true. This is another reason\n      // why deep is opt in.\n      const fn = calledWithFn({ fallbackMockImplementation: opts?.fallbackMockImplementation })\n      if (opts?.deep && property !== 'calls') {\n        obj[property] = new Proxy<MockProxy<any>>(fn, handler(opts))\n        obj[property]._isMockObject = true\n      } else {\n        obj[property] = fn\n      }\n    }\n\n    // @ts-expect-error expected type mismatch due to any\n    if (obj instanceof Date && typeof obj[property] === 'function') {\n      // @ts-expect-error expected type mismatch due to any\n      return obj[property].bind(obj)\n    }\n\n    return obj[property]\n  },\n})\n\nconst mock = <T, MockedReturn extends MockProxy<T> & T = MockProxy<T> & T>(\n  mockImplementation: DeepPartial<T> = {} as DeepPartial<T>,\n  opts?: MockOpts,\n): MockedReturn => {\n  // @ts-expect-error private\n  mockImplementation!._isMockObject = true\n  return overrideMockImp(mockImplementation, opts)\n}\n\nconst mockFn = <\n  T,\n  A extends any[] = T extends (...args: infer AReal) => any ? AReal : any[],\n  R = T extends (...args: any) => infer RReal ? RReal : any,\n>(): CalledWithMock<R, A> & T => {\n  // @ts-expect-error hard to get this type right using any\n  return calledWithFn()\n}\n\nfunction mocked<T>(obj: T, deep?: false): ReturnType<typeof mock<T>>\nfunction mocked<T>(obj: T, deep: true): ReturnType<typeof mockDeep<T>>\nfunction mocked<T>(obj: T, _deep?: boolean) {\n  return obj;\n}\n\nfunction mockedFn<T>(obj: T) {\n  return obj as ReturnType<typeof mockFn<T>>;\n}\n\nconst stub = <T extends object>(): T => {\n  return new Proxy<T>({} as T, {\n    get: (obj, property: ProxiedProperty) => {\n      if (property in obj) {\n        // @ts-expect-error expected\n        return obj[property]\n      }\n      return vi.fn()\n    },\n  })\n}\n\nexport { mock, VitestMockExtended, mockClear, mockReset, mockDeep, mockFn, stub, mocked, mockedFn }\nexport type { GlobalConfig, CalledWithMock, MockProxy, DeepMockProxy, MockOpts }\n"],"names":["calledWithFn","args","mock"],"mappings":"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"}