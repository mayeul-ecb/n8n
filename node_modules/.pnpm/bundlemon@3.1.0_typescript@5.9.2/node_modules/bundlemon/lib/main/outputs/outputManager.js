"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateOutputs = exports.initOutputs = exports.OutputManager = void 0;
const logger_1 = __importDefault(require("../../common/logger"));
const outputs_1 = require("./outputs");
const console_1 = __importDefault(require("./outputs/console"));
const utils_1 = require("./utils");
class OutputManager {
    outputs = [];
    outputCreator = (0, outputs_1.getAllOutputs)().reduce((prev, curr) => {
        return { ...prev, [curr.name]: curr.create };
    }, {});
    initOutputs = async (config) => {
        logger_1.default.debug('Init outputs');
        const consoleOutputInstance = await console_1.default.create({ config, options: undefined });
        if (!consoleOutputInstance) {
            throw new Error('Failed to create console output instance');
        }
        this.outputs.push({ name: console_1.default.name, instance: consoleOutputInstance });
        if (config.reportOutput.length > 0) {
            for (const output of config.reportOutput) {
                const { name, options = {} } = (0, utils_1.parseOutput)(output);
                if (!this.outputCreator[name]) {
                    throw new Error(`Cant find output "${name}"`);
                }
                try {
                    const instance = await this.outputCreator[name]({ config, options });
                    if (instance) {
                        this.outputs.push({ name, instance });
                    }
                    else {
                        logger_1.default.debug(`Ignoring output "${name}"`);
                    }
                }
                catch (err) {
                    throw new Error(`Error while creating "${name}" output: ${err.message}`);
                }
            }
        }
    };
    generateOutputs = async (report) => {
        logger_1.default.debug('generate outputs');
        for await (const output of this.getOutputs()) {
            const { name, instance } = output;
            logger_1.default.info(`Generate ${name} output`);
            try {
                await instance.generate(report);
            }
            catch (err) {
                throw new Error(`Error while generating "${name}" output. ${err.message}`);
            }
        }
    };
    getOutputs = () => this.outputs;
}
exports.OutputManager = OutputManager;
_a = new OutputManager(), exports.initOutputs = _a.initOutputs, exports.generateOutputs = _a.generateOutputs;
