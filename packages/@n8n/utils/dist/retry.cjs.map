{"version":3,"sources":["/home/mayeul/projects/n8n/packages/@n8n/utils/dist/retry.cjs","../src/retry.ts"],"names":[],"mappings":"AAAA;ACcA,MAAA,SAAsB,KAAA,CACrB,EAAA,EACA,SAAA,EAAmB,GAAA,EACnB,WAAA,EAAqB,CAAA,EACrB,QAAA,EAA2C,QAAA,EACxB;AACnB,EAAA,IAAI,QAAA,EAAU,CAAA;AAEd,EAAA,MAAA,CAAO,QAAA,EAAU,UAAA,EAAY;AAC5B,IAAA,OAAA,EAAA;AACA,IAAA,IAAI;AACH,MAAA,MAAM,OAAA,EAAS,MAAM,EAAA,CAAG,CAAA;AACxB,MAAA,GAAA,CAAI,MAAA,EAAQ;AACX,QAAA,OAAO,IAAA;AAAA,MACR;AAAA,IACD,EAAA,MAAA,CAAS,KAAA,EAAO;AACf,MAAA,OAAA,CAAQ,KAAA,CAAM,qBAAA,EAAuB,KAAK,CAAA;AAC1C,MAAA,MAAM,KAAA;AAAA,IACP;AAGA,IAAA,GAAA,CAAI,QAAA,EAAU,UAAA,EAAY;AACzB,MAAA,IAAI,iBAAA,EAAmB,QAAA;AAEvB,MAAA,GAAA,CAAI,QAAA,IAAY,QAAA,EAAU;AACzB,QAAA,iBAAA,EAAmB,SAAA,EAAW,OAAA;AAAA,MAC/B,EAAA,KAAA,GAAA,CAAW,QAAA,IAAY,aAAA,EAAe;AACrC,QAAA,iBAAA,EAAmB,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,QAAA,EAAU,CAAC,EAAA,EAAI,QAAA;AAC9C,QAAA,iBAAA,EAAmB,IAAA,CAAK,GAAA,CAAI,gBAAA,EAAkB,GAAK,CAAA;AAAA,MACpD;AAEA,MAAA,MAAM,IAAI,OAAA,CAAc,CAAC,OAAA,EAAA,GAAY,UAAA,CAAW,OAAA,EAAS,gBAAgB,CAAC,CAAA;AAAA,IAC3E;AAAA,EACD;AAEA,EAAA,OAAO,KAAA;AACR;ADvBA;AACE;AACF,sBAAC","file":"/home/mayeul/projects/n8n/packages/@n8n/utils/dist/retry.cjs","sourcesContent":[null,"type RetryFn = () => boolean | Promise<boolean>;\n\n/**\n * A utility that retries a function every `interval` milliseconds\n * until the function returns true or the maximum number of retries is reached.\n *\n * @param fn - A function that returns a boolean or a Promise resolving to a boolean.\n * @param interval - The time interval (in milliseconds) between each retry. Defaults to 1000.\n * @param maxRetries - The maximum number of retry attempts. Defaults to 3.\n * @param backoff - The backoff strategy to use: 'linear', 'exponential', or null.\n * @returns {Promise<boolean>} - A promise that resolves to:\n *   - true: If the function returns true before reaching maxRetries.\n *   - false: If the function never returns true or if an error occurs.\n */\nexport async function retry(\n\tfn: RetryFn,\n\tinterval: number = 1000,\n\tmaxRetries: number = 3,\n\tbackoff: 'exponential' | 'linear' | null = 'linear',\n): Promise<boolean> {\n\tlet attempt = 0;\n\n\twhile (attempt < maxRetries) {\n\t\tattempt++;\n\t\ttry {\n\t\t\tconst result = await fn();\n\t\t\tif (result) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error('Error during retry:', error);\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Wait for the specified interval before the next attempt, if any attempts remain.\n\t\tif (attempt < maxRetries) {\n\t\t\tlet computedInterval = interval;\n\n\t\t\tif (backoff === 'linear') {\n\t\t\t\tcomputedInterval = interval * attempt;\n\t\t\t} else if (backoff === 'exponential') {\n\t\t\t\tcomputedInterval = Math.pow(2, attempt - 1) * interval;\n\t\t\t\tcomputedInterval = Math.min(computedInterval, 30000); // Cap the maximum interval to 30 seconds\n\t\t\t}\n\n\t\t\tawait new Promise<void>((resolve) => setTimeout(resolve, computedInterval));\n\t\t}\n\t}\n\n\treturn false;\n}\n"]}