{"version":3,"sources":["../../src/search/sublimeSearch.ts"],"sourcesContent":["/*\n * Constants and utility functions used for searching for node types in node creator component\n * based on https://github.com/forrestthewoods/lib_fts/blob/master/code/fts_fuzzy_match.js\n */\n\nconst SEQUENTIAL_BONUS = 60; // bonus for adjacent matches\nconst SEPARATOR_BONUS = 38; // bonus if match occurs after a separator\nconst CAMEL_BONUS = 30; // bonus if match is uppercase and prev is lower\nconst FIRST_LETTER_BONUS = 15; // bonus if the first letter is matched\n\nconst LEADING_LETTER_PENALTY = -20; // penalty applied for every letter in str before the first match\nconst MAX_LEADING_LETTER_PENALTY = -200; // maximum penalty for leading letters\nconst UNMATCHED_LETTER_PENALTY = -5;\n\nexport const DEFAULT_KEYS = [\n\t{ key: 'properties.displayName', weight: 1.3 },\n\t{ key: 'properties.codex.alias', weight: 1 },\n];\n\n/**\n * Returns true if each character in pattern is found sequentially within target\n * @param {*} pattern string\n * @param {*} target string\n */\nfunction fuzzyMatchSimple(pattern: string, target: string): boolean {\n\tlet patternIdx = 0;\n\tlet strIdx = 0;\n\n\twhile (patternIdx < pattern.length && strIdx < target.length) {\n\t\tconst patternChar = pattern.charAt(patternIdx).toLowerCase();\n\t\tconst targetChar = target.charAt(strIdx).toLowerCase();\n\t\tif (patternChar === targetChar) {\n\t\t\tpatternIdx++;\n\t\t}\n\t\t++strIdx;\n\t}\n\n\treturn pattern.length !== 0 && target.length !== 0 && patternIdx === pattern.length;\n}\n\nfunction fuzzyMatchRecursive(\n\tpattern: string,\n\ttarget: string,\n\tpatternCurIndex: number,\n\ttargetCurrIndex: number,\n\ttargetMatches: null | number[],\n\tmatches: number[],\n\tmaxMatches: number,\n\tnextMatch: number,\n\trecursionCount: number,\n\trecursionLimit: number,\n): { matched: boolean; outScore: number } {\n\tlet outScore = 0;\n\n\t// Return if recursion limit is reached.\n\tif (++recursionCount >= recursionLimit) {\n\t\treturn { matched: false, outScore };\n\t}\n\n\t// Return if we reached ends of strings.\n\tif (patternCurIndex === pattern.length || targetCurrIndex === target.length) {\n\t\treturn { matched: false, outScore };\n\t}\n\n\t// Recursion params\n\tlet recursiveMatch = false;\n\tlet bestRecursiveMatches: number[] = [];\n\tlet bestRecursiveScore = 0;\n\n\t// Loop through pattern and str looking for a match.\n\tlet firstMatch = true;\n\twhile (patternCurIndex < pattern.length && targetCurrIndex < target.length) {\n\t\t// Match found.\n\t\tif (pattern[patternCurIndex].toLowerCase() === target[targetCurrIndex].toLowerCase()) {\n\t\t\tif (nextMatch >= maxMatches) {\n\t\t\t\treturn { matched: false, outScore };\n\t\t\t}\n\n\t\t\tif (firstMatch && targetMatches) {\n\t\t\t\tmatches = [...targetMatches];\n\t\t\t\tfirstMatch = false;\n\t\t\t}\n\n\t\t\tconst recursiveMatches: number[] = [];\n\t\t\tconst recursiveResult = fuzzyMatchRecursive(\n\t\t\t\tpattern,\n\t\t\t\ttarget,\n\t\t\t\tpatternCurIndex,\n\t\t\t\ttargetCurrIndex + 1,\n\t\t\t\tmatches,\n\t\t\t\trecursiveMatches,\n\t\t\t\tmaxMatches,\n\t\t\t\tnextMatch,\n\t\t\t\trecursionCount,\n\t\t\t\trecursionLimit,\n\t\t\t);\n\n\t\t\tconst recursiveScore = recursiveResult.outScore;\n\t\t\tif (recursiveResult.matched) {\n\t\t\t\t// Pick best recursive score.\n\t\t\t\tif (!recursiveMatch || recursiveScore > bestRecursiveScore) {\n\t\t\t\t\tbestRecursiveMatches = [...recursiveMatches];\n\t\t\t\t\tbestRecursiveScore = recursiveScore;\n\t\t\t\t}\n\t\t\t\trecursiveMatch = true;\n\t\t\t}\n\n\t\t\tmatches[nextMatch++] = targetCurrIndex;\n\t\t\t++patternCurIndex;\n\t\t}\n\t\t++targetCurrIndex;\n\t}\n\n\tconst matched = patternCurIndex === pattern.length;\n\n\tif (matched) {\n\t\toutScore = 100;\n\n\t\t// Apply leading letter penalty (if not n8n-prefixed)\n\t\tif (!target.toLowerCase().startsWith('n8n')) {\n\t\t\tlet penalty = LEADING_LETTER_PENALTY * matches[0];\n\t\t\tpenalty = penalty < MAX_LEADING_LETTER_PENALTY ? MAX_LEADING_LETTER_PENALTY : penalty;\n\t\t\toutScore += penalty;\n\t\t}\n\n\t\t//Apply unmatched penalty\n\t\tconst unmatched = target.length - nextMatch;\n\t\toutScore += UNMATCHED_LETTER_PENALTY * unmatched;\n\n\t\t// Apply ordering bonuses\n\t\tfor (let i = 0; i < nextMatch; i++) {\n\t\t\tconst currIdx = matches[i];\n\n\t\t\tif (i > 0) {\n\t\t\t\tconst prevIdx = matches[i - 1];\n\t\t\t\tif (currIdx === prevIdx + 1) {\n\t\t\t\t\toutScore += SEQUENTIAL_BONUS;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for bonuses based on neighbor character value.\n\t\t\tif (currIdx > 0) {\n\t\t\t\t// Camel case\n\t\t\t\tconst neighbor = target[currIdx - 1];\n\t\t\t\tconst curr = target[currIdx];\n\t\t\t\tif (neighbor !== neighbor.toUpperCase() && curr !== curr.toLowerCase()) {\n\t\t\t\t\toutScore += CAMEL_BONUS;\n\t\t\t\t}\n\t\t\t\tconst isNeighbourSeparator = neighbor === '_' || neighbor === ' ';\n\t\t\t\tif (isNeighbourSeparator) {\n\t\t\t\t\toutScore += SEPARATOR_BONUS;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// First letter\n\t\t\t\toutScore += FIRST_LETTER_BONUS;\n\t\t\t}\n\t\t}\n\n\t\t// Return best result\n\t\tif (recursiveMatch && (!matched || bestRecursiveScore > outScore)) {\n\t\t\t// Recursive score is better than \"this\"\n\t\t\tmatches = [...bestRecursiveMatches];\n\t\t\toutScore = bestRecursiveScore;\n\t\t\treturn { matched: true, outScore };\n\t\t} else if (matched) {\n\t\t\t// \"this\" score is better than recursive\n\t\t\treturn { matched: true, outScore };\n\t\t} else {\n\t\t\treturn { matched: false, outScore };\n\t\t}\n\t}\n\treturn { matched: false, outScore };\n}\n\n/**\n * Does a fuzzy search to find pattern inside a string.\n * @param {*} pattern string        pattern to search for\n * @param {*} target     string        string which is being searched\n * @returns [boolean, number]       a boolean which tells if pattern was\n *                                  found or not and a search score\n */\nfunction fuzzyMatch(pattern: string, target: string): { matched: boolean; outScore: number } {\n\tconst recursionCount = 0;\n\tconst recursionLimit = 5;\n\tconst matches: number[] = [];\n\tconst maxMatches = 256;\n\n\treturn fuzzyMatchRecursive(\n\t\tpattern,\n\t\ttarget,\n\t\t0 /* patternCurIndex */,\n\t\t0 /* strCurrIndex */,\n\t\tnull /* srcMatces */,\n\t\tmatches,\n\t\tmaxMatches,\n\t\t0 /* nextMatch */,\n\t\trecursionCount,\n\t\trecursionLimit,\n\t);\n}\n\n// prop = 'key'\n// prop = 'key1.key2'\n// prop = ['key1', 'key2']\nfunction getValue<T extends object>(obj: T, prop: string): unknown {\n\tif (obj.hasOwnProperty(prop)) {\n\t\treturn obj[prop as keyof T];\n\t}\n\n\tconst segments = prop.split('.');\n\n\tlet result = obj;\n\tlet i = 0;\n\twhile (result && i < segments.length) {\n\t\tconst key = segments[i] as keyof T;\n\t\tresult = result[key] as T;\n\t\ti++;\n\t}\n\treturn result;\n}\n\nexport function sublimeSearch<T extends object>(\n\tfilter: string,\n\tdata: readonly T[],\n\tkeys: Array<{ key: string; weight: number }> = DEFAULT_KEYS,\n): Array<{ score: number; item: T }> {\n\tconst results = data.reduce((accu: Array<{ score: number; item: T }>, item: T) => {\n\t\tlet values: Array<{ value: string; weight: number }> = [];\n\t\tkeys.forEach(({ key, weight }) => {\n\t\t\tconst value = getValue(item, key);\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\t\t\t\tvalues = values.concat(value.map((v) => ({ value: v, weight })));\n\t\t\t} else if (typeof value === 'string') {\n\t\t\t\tvalues.push({\n\t\t\t\t\tvalue,\n\t\t\t\t\tweight,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\t// for each item, check every key and get maximum score\n\t\tconst itemMatch = values.reduce(\n\t\t\t(\n\t\t\t\tresult: null | { matched: boolean; outScore: number },\n\t\t\t\t{ value, weight }: { value: string; weight: number },\n\t\t\t) => {\n\t\t\t\tif (!fuzzyMatchSimple(filter, value)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tconst match = fuzzyMatch(filter, value);\n\t\t\t\tmatch.outScore *= weight;\n\n\t\t\t\tconst { matched, outScore } = match;\n\t\t\t\tif (!result && matched) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tif (matched && result && outScore > result.outScore) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\tnull,\n\t\t);\n\n\t\tif (itemMatch) {\n\t\t\taccu.push({\n\t\t\t\tscore: itemMatch.outScore,\n\t\t\t\titem,\n\t\t\t});\n\t\t}\n\n\t\treturn accu;\n\t}, []);\n\n\tresults.sort((a, b) => {\n\t\treturn b.score - a.score;\n\t});\n\n\treturn results;\n}\n"],"mappings":"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","names":[]}