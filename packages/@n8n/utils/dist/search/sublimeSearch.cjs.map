{"version":3,"sources":["/home/mayeul/projects/n8n/packages/@n8n/utils/dist/search/sublimeSearch.cjs","../../src/search/sublimeSearch.ts"],"names":[],"mappings":"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","file":"/home/mayeul/projects/n8n/packages/@n8n/utils/dist/search/sublimeSearch.cjs","sourcesContent":[null,"/*\n * Constants and utility functions used for searching for node types in node creator component\n * based on https://github.com/forrestthewoods/lib_fts/blob/master/code/fts_fuzzy_match.js\n */\n\nconst SEQUENTIAL_BONUS = 60; // bonus for adjacent matches\nconst SEPARATOR_BONUS = 38; // bonus if match occurs after a separator\nconst CAMEL_BONUS = 30; // bonus if match is uppercase and prev is lower\nconst FIRST_LETTER_BONUS = 15; // bonus if the first letter is matched\n\nconst LEADING_LETTER_PENALTY = -20; // penalty applied for every letter in str before the first match\nconst MAX_LEADING_LETTER_PENALTY = -200; // maximum penalty for leading letters\nconst UNMATCHED_LETTER_PENALTY = -5;\n\nexport const DEFAULT_KEYS = [\n\t{ key: 'properties.displayName', weight: 1.3 },\n\t{ key: 'properties.codex.alias', weight: 1 },\n];\n\n/**\n * Returns true if each character in pattern is found sequentially within target\n * @param {*} pattern string\n * @param {*} target string\n */\nfunction fuzzyMatchSimple(pattern: string, target: string): boolean {\n\tlet patternIdx = 0;\n\tlet strIdx = 0;\n\n\twhile (patternIdx < pattern.length && strIdx < target.length) {\n\t\tconst patternChar = pattern.charAt(patternIdx).toLowerCase();\n\t\tconst targetChar = target.charAt(strIdx).toLowerCase();\n\t\tif (patternChar === targetChar) {\n\t\t\tpatternIdx++;\n\t\t}\n\t\t++strIdx;\n\t}\n\n\treturn pattern.length !== 0 && target.length !== 0 && patternIdx === pattern.length;\n}\n\nfunction fuzzyMatchRecursive(\n\tpattern: string,\n\ttarget: string,\n\tpatternCurIndex: number,\n\ttargetCurrIndex: number,\n\ttargetMatches: null | number[],\n\tmatches: number[],\n\tmaxMatches: number,\n\tnextMatch: number,\n\trecursionCount: number,\n\trecursionLimit: number,\n): { matched: boolean; outScore: number } {\n\tlet outScore = 0;\n\n\t// Return if recursion limit is reached.\n\tif (++recursionCount >= recursionLimit) {\n\t\treturn { matched: false, outScore };\n\t}\n\n\t// Return if we reached ends of strings.\n\tif (patternCurIndex === pattern.length || targetCurrIndex === target.length) {\n\t\treturn { matched: false, outScore };\n\t}\n\n\t// Recursion params\n\tlet recursiveMatch = false;\n\tlet bestRecursiveMatches: number[] = [];\n\tlet bestRecursiveScore = 0;\n\n\t// Loop through pattern and str looking for a match.\n\tlet firstMatch = true;\n\twhile (patternCurIndex < pattern.length && targetCurrIndex < target.length) {\n\t\t// Match found.\n\t\tif (pattern[patternCurIndex].toLowerCase() === target[targetCurrIndex].toLowerCase()) {\n\t\t\tif (nextMatch >= maxMatches) {\n\t\t\t\treturn { matched: false, outScore };\n\t\t\t}\n\n\t\t\tif (firstMatch && targetMatches) {\n\t\t\t\tmatches = [...targetMatches];\n\t\t\t\tfirstMatch = false;\n\t\t\t}\n\n\t\t\tconst recursiveMatches: number[] = [];\n\t\t\tconst recursiveResult = fuzzyMatchRecursive(\n\t\t\t\tpattern,\n\t\t\t\ttarget,\n\t\t\t\tpatternCurIndex,\n\t\t\t\ttargetCurrIndex + 1,\n\t\t\t\tmatches,\n\t\t\t\trecursiveMatches,\n\t\t\t\tmaxMatches,\n\t\t\t\tnextMatch,\n\t\t\t\trecursionCount,\n\t\t\t\trecursionLimit,\n\t\t\t);\n\n\t\t\tconst recursiveScore = recursiveResult.outScore;\n\t\t\tif (recursiveResult.matched) {\n\t\t\t\t// Pick best recursive score.\n\t\t\t\tif (!recursiveMatch || recursiveScore > bestRecursiveScore) {\n\t\t\t\t\tbestRecursiveMatches = [...recursiveMatches];\n\t\t\t\t\tbestRecursiveScore = recursiveScore;\n\t\t\t\t}\n\t\t\t\trecursiveMatch = true;\n\t\t\t}\n\n\t\t\tmatches[nextMatch++] = targetCurrIndex;\n\t\t\t++patternCurIndex;\n\t\t}\n\t\t++targetCurrIndex;\n\t}\n\n\tconst matched = patternCurIndex === pattern.length;\n\n\tif (matched) {\n\t\toutScore = 100;\n\n\t\t// Apply leading letter penalty (if not n8n-prefixed)\n\t\tif (!target.toLowerCase().startsWith('n8n')) {\n\t\t\tlet penalty = LEADING_LETTER_PENALTY * matches[0];\n\t\t\tpenalty = penalty < MAX_LEADING_LETTER_PENALTY ? MAX_LEADING_LETTER_PENALTY : penalty;\n\t\t\toutScore += penalty;\n\t\t}\n\n\t\t//Apply unmatched penalty\n\t\tconst unmatched = target.length - nextMatch;\n\t\toutScore += UNMATCHED_LETTER_PENALTY * unmatched;\n\n\t\t// Apply ordering bonuses\n\t\tfor (let i = 0; i < nextMatch; i++) {\n\t\t\tconst currIdx = matches[i];\n\n\t\t\tif (i > 0) {\n\t\t\t\tconst prevIdx = matches[i - 1];\n\t\t\t\tif (currIdx === prevIdx + 1) {\n\t\t\t\t\toutScore += SEQUENTIAL_BONUS;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for bonuses based on neighbor character value.\n\t\t\tif (currIdx > 0) {\n\t\t\t\t// Camel case\n\t\t\t\tconst neighbor = target[currIdx - 1];\n\t\t\t\tconst curr = target[currIdx];\n\t\t\t\tif (neighbor !== neighbor.toUpperCase() && curr !== curr.toLowerCase()) {\n\t\t\t\t\toutScore += CAMEL_BONUS;\n\t\t\t\t}\n\t\t\t\tconst isNeighbourSeparator = neighbor === '_' || neighbor === ' ';\n\t\t\t\tif (isNeighbourSeparator) {\n\t\t\t\t\toutScore += SEPARATOR_BONUS;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// First letter\n\t\t\t\toutScore += FIRST_LETTER_BONUS;\n\t\t\t}\n\t\t}\n\n\t\t// Return best result\n\t\tif (recursiveMatch && (!matched || bestRecursiveScore > outScore)) {\n\t\t\t// Recursive score is better than \"this\"\n\t\t\tmatches = [...bestRecursiveMatches];\n\t\t\toutScore = bestRecursiveScore;\n\t\t\treturn { matched: true, outScore };\n\t\t} else if (matched) {\n\t\t\t// \"this\" score is better than recursive\n\t\t\treturn { matched: true, outScore };\n\t\t} else {\n\t\t\treturn { matched: false, outScore };\n\t\t}\n\t}\n\treturn { matched: false, outScore };\n}\n\n/**\n * Does a fuzzy search to find pattern inside a string.\n * @param {*} pattern string        pattern to search for\n * @param {*} target     string        string which is being searched\n * @returns [boolean, number]       a boolean which tells if pattern was\n *                                  found or not and a search score\n */\nfunction fuzzyMatch(pattern: string, target: string): { matched: boolean; outScore: number } {\n\tconst recursionCount = 0;\n\tconst recursionLimit = 5;\n\tconst matches: number[] = [];\n\tconst maxMatches = 256;\n\n\treturn fuzzyMatchRecursive(\n\t\tpattern,\n\t\ttarget,\n\t\t0 /* patternCurIndex */,\n\t\t0 /* strCurrIndex */,\n\t\tnull /* srcMatces */,\n\t\tmatches,\n\t\tmaxMatches,\n\t\t0 /* nextMatch */,\n\t\trecursionCount,\n\t\trecursionLimit,\n\t);\n}\n\n// prop = 'key'\n// prop = 'key1.key2'\n// prop = ['key1', 'key2']\nfunction getValue<T extends object>(obj: T, prop: string): unknown {\n\tif (obj.hasOwnProperty(prop)) {\n\t\treturn obj[prop as keyof T];\n\t}\n\n\tconst segments = prop.split('.');\n\n\tlet result = obj;\n\tlet i = 0;\n\twhile (result && i < segments.length) {\n\t\tconst key = segments[i] as keyof T;\n\t\tresult = result[key] as T;\n\t\ti++;\n\t}\n\treturn result;\n}\n\nexport function sublimeSearch<T extends object>(\n\tfilter: string,\n\tdata: readonly T[],\n\tkeys: Array<{ key: string; weight: number }> = DEFAULT_KEYS,\n): Array<{ score: number; item: T }> {\n\tconst results = data.reduce((accu: Array<{ score: number; item: T }>, item: T) => {\n\t\tlet values: Array<{ value: string; weight: number }> = [];\n\t\tkeys.forEach(({ key, weight }) => {\n\t\t\tconst value = getValue(item, key);\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\t\t\t\tvalues = values.concat(value.map((v) => ({ value: v, weight })));\n\t\t\t} else if (typeof value === 'string') {\n\t\t\t\tvalues.push({\n\t\t\t\t\tvalue,\n\t\t\t\t\tweight,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\t// for each item, check every key and get maximum score\n\t\tconst itemMatch = values.reduce(\n\t\t\t(\n\t\t\t\tresult: null | { matched: boolean; outScore: number },\n\t\t\t\t{ value, weight }: { value: string; weight: number },\n\t\t\t) => {\n\t\t\t\tif (!fuzzyMatchSimple(filter, value)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tconst match = fuzzyMatch(filter, value);\n\t\t\t\tmatch.outScore *= weight;\n\n\t\t\t\tconst { matched, outScore } = match;\n\t\t\t\tif (!result && matched) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tif (matched && result && outScore > result.outScore) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\tnull,\n\t\t);\n\n\t\tif (itemMatch) {\n\t\t\taccu.push({\n\t\t\t\tscore: itemMatch.outScore,\n\t\t\t\titem,\n\t\t\t});\n\t\t}\n\n\t\treturn accu;\n\t}, []);\n\n\tresults.sort((a, b) => {\n\t\treturn b.score - a.score;\n\t});\n\n\treturn results;\n}\n"]}