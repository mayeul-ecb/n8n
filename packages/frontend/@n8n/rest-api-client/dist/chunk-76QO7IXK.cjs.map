{"version":3,"sources":["/home/mayeul/projects/n8n/packages/frontend/@n8n/rest-api-client/dist/chunk-76QO7IXK.cjs","../src/utils.ts"],"names":[],"mappings":"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","file":"/home/mayeul/projects/n8n/packages/frontend/@n8n/rest-api-client/dist/chunk-76QO7IXK.cjs","sourcesContent":[null,"import { BROWSER_ID_STORAGE_KEY } from '@n8n/constants';\nimport { assert } from '@n8n/utils/assert';\nimport type { AxiosRequestConfig, Method, RawAxiosRequestHeaders } from 'axios';\nimport axios from 'axios';\nimport { ApplicationError, jsonParse } from 'n8n-workflow';\nimport type { GenericValue, IDataObject } from 'n8n-workflow';\n\nimport type { IRestApiContext } from './types';\n\nconst getBrowserId = () => {\n\tlet browserId = localStorage.getItem(BROWSER_ID_STORAGE_KEY);\n\tif (!browserId) {\n\t\tbrowserId = crypto.randomUUID();\n\t\tlocalStorage.setItem(BROWSER_ID_STORAGE_KEY, browserId);\n\t}\n\treturn browserId;\n};\n\nexport const NO_NETWORK_ERROR_CODE = 999;\nexport const STREAM_SEPERATOR = '⧉⇋⇋➽⌑⧉§§\\n';\n\nexport class MfaRequiredError extends ApplicationError {\n\tconstructor() {\n\t\tsuper('MFA is required to access this resource. Please set up MFA in your user settings.');\n\t\tthis.name = 'MfaRequiredError';\n\t}\n}\n\nexport class ResponseError extends ApplicationError {\n\t// The HTTP status code of response\n\thttpStatusCode?: number;\n\n\t// The error code in the response\n\terrorCode?: number;\n\n\t// The stack trace of the server\n\tserverStackTrace?: string;\n\n\t/**\n\t * Creates an instance of ResponseError.\n\t * @param {string} message The error message\n\t * @param {number} [errorCode] The error code which can be used by frontend to identify the actual error\n\t * @param {number} [httpStatusCode] The HTTP status code the response should have\n\t * @param {string} [stack] The stack trace\n\t */\n\tconstructor(\n\t\tmessage: string,\n\t\toptions: { errorCode?: number; httpStatusCode?: number; stack?: string } = {},\n\t) {\n\t\tsuper(message);\n\t\tthis.name = 'ResponseError';\n\n\t\tconst { errorCode, httpStatusCode, stack } = options;\n\t\tif (errorCode) {\n\t\t\tthis.errorCode = errorCode;\n\t\t}\n\t\tif (httpStatusCode) {\n\t\t\tthis.httpStatusCode = httpStatusCode;\n\t\t}\n\t\tif (stack) {\n\t\t\tthis.serverStackTrace = stack;\n\t\t}\n\t}\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst legacyParamSerializer = (params: Record<string, any>) =>\n\tObject.keys(params)\n\t\t.filter((key) => params[key] !== undefined)\n\t\t.map((key) => {\n\t\t\tif (Array.isArray(params[key])) {\n\t\t\t\treturn params[key].map((v: string) => `${key}[]=${encodeURIComponent(v)}`).join('&');\n\t\t\t}\n\t\t\tif (typeof params[key] === 'object') {\n\t\t\t\tparams[key] = JSON.stringify(params[key]);\n\t\t\t}\n\t\t\treturn `${key}=${encodeURIComponent(params[key])}`;\n\t\t})\n\t\t.join('&');\n\nexport async function request(config: {\n\tmethod: Method;\n\tbaseURL: string;\n\tendpoint: string;\n\theaders?: RawAxiosRequestHeaders;\n\tdata?: GenericValue | GenericValue[];\n\twithCredentials?: boolean;\n}) {\n\tconst { method, baseURL, endpoint, headers, data } = config;\n\tconst options: AxiosRequestConfig = {\n\t\tmethod,\n\t\turl: endpoint,\n\t\tbaseURL,\n\t\theaders: headers ?? {},\n\t};\n\tif (baseURL.startsWith('/')) {\n\t\toptions.headers!['browser-id'] = getBrowserId();\n\t}\n\tif (\n\t\timport.meta.env.NODE_ENV !== 'production' &&\n\t\t!baseURL.includes('api.n8n.io') &&\n\t\t!baseURL.includes('n8n.cloud')\n\t) {\n\t\toptions.withCredentials = options.withCredentials ?? true;\n\t}\n\tif (['POST', 'PATCH', 'PUT'].includes(method)) {\n\t\toptions.data = data;\n\t} else if (data) {\n\t\toptions.params = data;\n\t\toptions.paramsSerializer = legacyParamSerializer;\n\t}\n\n\ttry {\n\t\tconst response = await axios.request(options);\n\t\treturn response.data;\n\t} catch (error) {\n\t\tif (error.message === 'Network Error') {\n\t\t\tthrow new ResponseError(\"Can't connect to n8n.\", {\n\t\t\t\terrorCode: NO_NETWORK_ERROR_CODE,\n\t\t\t});\n\t\t}\n\n\t\tconst errorResponseData = error.response?.data;\n\t\tif (errorResponseData?.mfaRequired === true) {\n\t\t\tthrow new MfaRequiredError();\n\t\t}\n\t\tif (errorResponseData?.message !== undefined) {\n\t\t\tif (errorResponseData.name === 'NodeApiError') {\n\t\t\t\terrorResponseData.httpStatusCode = error.response.status;\n\t\t\t\tthrow errorResponseData;\n\t\t\t}\n\n\t\t\tthrow new ResponseError(errorResponseData.message, {\n\t\t\t\terrorCode: errorResponseData.code,\n\t\t\t\thttpStatusCode: error.response.status,\n\t\t\t\tstack: errorResponseData.stack,\n\t\t\t});\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n\n/**\n * Sends a request to the API and returns the response without extracting the data key.\n * @param context Rest API context\n * @param method HTTP method\n * @param endpoint relative path to the API endpoint\n * @param data request data\n * @returns data and total count\n */\nexport async function getFullApiResponse<T>(\n\tcontext: IRestApiContext,\n\tmethod: Method,\n\tendpoint: string,\n\tdata?: GenericValue | GenericValue[],\n) {\n\tconst response = await request({\n\t\tmethod,\n\t\tbaseURL: context.baseUrl,\n\t\tendpoint,\n\t\theaders: { 'push-ref': context.pushRef },\n\t\tdata,\n\t});\n\n\treturn response as { count: number; data: T };\n}\n\nexport async function makeRestApiRequest<T>(\n\tcontext: IRestApiContext,\n\tmethod: Method,\n\tendpoint: string,\n\tdata?: GenericValue | GenericValue[],\n) {\n\tconst response = await request({\n\t\tmethod,\n\t\tbaseURL: context.baseUrl,\n\t\tendpoint,\n\t\theaders: { 'push-ref': context.pushRef },\n\t\tdata,\n\t});\n\n\t// All cli rest api endpoints return data wrapped in `data` key\n\treturn response.data as T;\n}\n\nexport async function get(\n\tbaseURL: string,\n\tendpoint: string,\n\tparams?: IDataObject,\n\theaders?: RawAxiosRequestHeaders,\n) {\n\treturn await request({ method: 'GET', baseURL, endpoint, headers, data: params });\n}\n\nexport async function post(\n\tbaseURL: string,\n\tendpoint: string,\n\tparams?: IDataObject,\n\theaders?: RawAxiosRequestHeaders,\n) {\n\treturn await request({ method: 'POST', baseURL, endpoint, headers, data: params });\n}\n\nexport async function patch(\n\tbaseURL: string,\n\tendpoint: string,\n\tparams?: IDataObject,\n\theaders?: RawAxiosRequestHeaders,\n) {\n\treturn await request({ method: 'PATCH', baseURL, endpoint, headers, data: params });\n}\n\nexport async function streamRequest<T extends object>(\n\tcontext: IRestApiContext,\n\tapiEndpoint: string,\n\tpayload: object,\n\tonChunk?: (chunk: T) => void,\n\tonDone?: () => void,\n\tonError?: (e: Error) => void,\n\tseparator = STREAM_SEPERATOR,\n\tabortSignal?: AbortSignal,\n): Promise<void> {\n\tconst headers: Record<string, string> = {\n\t\t'browser-id': getBrowserId(),\n\t\t'Content-Type': 'application/json',\n\t};\n\tconst assistantRequest: RequestInit = {\n\t\theaders,\n\t\tmethod: 'POST',\n\t\tcredentials: 'include',\n\t\tbody: JSON.stringify(payload),\n\t\tsignal: abortSignal,\n\t};\n\ttry {\n\t\tconst response = await fetch(`${context.baseUrl}${apiEndpoint}`, assistantRequest);\n\n\t\tif (response.body) {\n\t\t\t// Handle the streaming response\n\t\t\tconst reader = response.body.getReader();\n\t\t\tconst decoder = new TextDecoder('utf-8');\n\n\t\t\tlet buffer = '';\n\n\t\t\tasync function readStream() {\n\t\t\t\tconst { done, value } = await reader.read();\n\t\t\t\tif (done) {\n\t\t\t\t\tonDone?.();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst chunk = decoder.decode(value);\n\t\t\t\tbuffer += chunk;\n\n\t\t\t\tconst splitChunks = buffer.split(separator);\n\n\t\t\t\tbuffer = '';\n\t\t\t\tfor (const splitChunk of splitChunks) {\n\t\t\t\t\tif (splitChunk) {\n\t\t\t\t\t\tlet data: T;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdata = jsonParse<T>(splitChunk, { errorMessage: 'Invalid json' });\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t// incomplete json. append to buffer to complete\n\t\t\t\t\t\t\tbuffer += splitChunk;\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\t\t// Call chunk callback if request was successful\n\t\t\t\t\t\t\t\tonChunk?.(data);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Otherwise, call error callback\n\t\t\t\t\t\t\t\tconst message = 'message' in data ? data.message : response.statusText;\n\t\t\t\t\t\t\t\tonError?.(\n\t\t\t\t\t\t\t\t\tnew ResponseError(String(message), {\n\t\t\t\t\t\t\t\t\t\thttpStatusCode: response.status,\n\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (e: unknown) {\n\t\t\t\t\t\t\tif (e instanceof Error) {\n\t\t\t\t\t\t\t\tonError?.(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tawait readStream();\n\t\t\t}\n\n\t\t\t// Start reading the stream\n\t\t\tawait readStream();\n\t\t} else if (onError) {\n\t\t\tonError(new Error(response.statusText));\n\t\t}\n\t} catch (e: unknown) {\n\t\tassert(e instanceof Error);\n\t\tonError?.(e);\n\t}\n}\n"]}