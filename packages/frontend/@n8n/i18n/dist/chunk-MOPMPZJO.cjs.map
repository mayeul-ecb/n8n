{"version":3,"sources":["/home/mayeul/projects/n8n/packages/frontend/@n8n/i18n/dist/chunk-MOPMPZJO.cjs","../src/utils.ts"],"names":[],"mappings":"AAAA;ACQO,SAAS,eAAA,CAAgB,IAAA,EAAc,SAAA,EAA4C;AACzF,EAAA,IAAI,UAAA,EAAY,SAAA,CAAU,IAAA;AAE1B,EAAA,GAAA,CAAI,oBAAA,CAAqB,IAAA,EAAM,SAAS,EAAA,GAAK,wBAAA,CAAyB,IAAI,CAAA,EAAG;AAC5E,IAAA,MAAM,aAAA,EAAe,SAAA,CAAU,IAAI,CAAA,CAAE,KAAA,CAAM,GAAG,CAAA;AAC9C,IAAA,UAAA,EAAY,sBAAA,CAAuB,YAAY,CAAA,CAAE,IAAA,CAAK,GAAG,CAAA;AAAA,EAC1D;AAEA,EAAA,GAAA,CAAI,kBAAA,CAAmB,IAAA,EAAM,SAAS,EAAA,GAAK,iBAAA,CAAkB,IAAA,EAAM,SAAS,CAAA,EAAG;AAC9E,IAAA,MAAM,aAAA,EAAe,CAAC,GAAG,SAAA,CAAU,IAAI,CAAA,CAAE,KAAA,CAAM,GAAG,CAAA,EAAG,SAAA,CAAU,IAAI,CAAA;AACnE,IAAA,UAAA,EAAY,sBAAA,CAAuB,YAAY,CAAA,CAAE,IAAA,CAAK,GAAG,CAAA;AAAA,EAC1D;AAEA,EAAA,OAAO,SAAA;AACR;AAMO,IAAM,yBAAA,EAA2B,CAAC,IAAA,EAAA,GAAiB,IAAA,CAAK,KAAA,CAAM,GAAG,CAAA,CAAE,OAAA,GAAU,CAAA;AAEpF,IAAM,qBAAA,EAAuB,CAAC,IAAA,EAAc,SAAA,EAAA,GAC3C,IAAA,CAAK,KAAA,CAAM,GAAG,CAAA,CAAE,OAAA,IAAW,EAAA,GAAK,SAAA,CAAU,KAAA,IAAS,YAAA;AAEpD,IAAM,mBAAA,EAAqB,CAAC,IAAA,EAAc,SAAA,EAAA,GACzC,IAAA,CAAK,KAAA,CAAM,GAAG,CAAA,CAAE,OAAA,EAAS,EAAA,GAAK,SAAA,CAAU,KAAA,IAAS,YAAA;AAMlD,IAAM,kBAAA,EAAoB,CAAC,IAAA,EAAc,SAAA,EAAA,GACxC,SAAA,CAAU,KAAA,IAAS,kBAAA,GAAqB,KAAA,IAAS,YAAA;AAO3C,IAAM,UAAA,EAAY,CAAC,IAAA,EAAA,GAAiB,IAAA,CAAK,OAAA,CAAQ,UAAA,EAAY,EAAE,CAAA,CAAE,OAAA,CAAQ,aAAA,EAAe,EAAE,CAAA;AAQ1F,IAAM,uBAAA,EAAyB,CAAC,YAAA,EAAA,GAA2B;AACjE,EAAA,OAAO,YAAA,CAAa,MAAA,CAAiB,CAAC,GAAA,EAAK,GAAA,EAAK,CAAA,EAAA,GAAM;AACrD,IAAA,GAAA,CAAI,IAAA,CAAK,GAAG,CAAA;AAEZ,IAAA,GAAA,CAAI,EAAA,IAAM,YAAA,CAAa,OAAA,EAAS,CAAA,EAAG,OAAO,GAAA;AAE1C,IAAA,GAAA,CAAI,IAAA,CAAK,EAAA,EAAI,EAAA,IAAM,EAAA,EAAI,UAAA,EAAY,QAAQ,CAAA;AAE3C,IAAA,OAAO,GAAA;AAAA,EACR,CAAA,EAAG,CAAC,CAAC,CAAA;AACN,CAAA;ADxCA;AACA;AACE;AACA;AACA;AACA;AACF,+LAAC","file":"/home/mayeul/projects/n8n/packages/frontend/@n8n/i18n/dist/chunk-MOPMPZJO.cjs","sourcesContent":[null,"/**\n * Derive the middle key, i.e. the segment of the render key located between\n * the initial key (path to parameters root) and the property to render.\n *\n * Used by `nodeText()` to handle nested params.\n *\n * Location: `n8n-nodes-base.nodes.github.nodeView.<middleKey>.placeholder`\n */\nexport function deriveMiddleKey(path: string, parameter: { name: string; type?: string }) {\n\tlet middleKey = parameter.name;\n\n\tif (isTopLevelCollection(path, parameter) || isNestedInCollectionLike(path)) {\n\t\tconst pathSegments = normalize(path).split('.');\n\t\tmiddleKey = insertOptionsAndValues(pathSegments).join('.');\n\t}\n\n\tif (isNestedCollection(path, parameter) || isFixedCollection(path, parameter)) {\n\t\tconst pathSegments = [...normalize(path).split('.'), parameter.name];\n\t\tmiddleKey = insertOptionsAndValues(pathSegments).join('.');\n\t}\n\n\treturn middleKey;\n}\n\n/**\n * Check if a param path is for a param nested inside a `collection` or\n * `fixedCollection` param.\n */\nexport const isNestedInCollectionLike = (path: string) => path.split('.').length >= 3;\n\nconst isTopLevelCollection = (path: string, parameter: { type?: string }) =>\n\tpath.split('.').length === 2 && parameter.type === 'collection';\n\nconst isNestedCollection = (path: string, parameter: { type?: string }) =>\n\tpath.split('.').length > 2 && parameter.type === 'collection';\n\n/**\n * Check if the param is a normal `fixedCollection`, i.e. a FC other than the wrapper\n * that sits at the root of a node's top-level param and contains all of them.\n */\nconst isFixedCollection = (path: string, parameter: { type?: string }) =>\n\tparameter.type === 'fixedCollection' && path !== 'parameters';\n\n/**\n * Remove all indices and the `parameters.` prefix from a parameter path.\n *\n * Example: `parameters.a[0].b` → `a.b`\n */\nexport const normalize = (path: string) => path.replace(/\\[.*?\\]/g, '').replace('parameters.', '');\n\n/**\n * Insert `'options'` and `'values'` on an alternating basis in a string array of\n * indefinite length. Helper to create a valid render key for a collection-like param.\n *\n * Example: `['a', 'b', 'c']` → `['a', 'options', 'b', 'values', 'c']`\n */\nexport const insertOptionsAndValues = (pathSegments: string[]) => {\n\treturn pathSegments.reduce<string[]>((acc, cur, i) => {\n\t\tacc.push(cur);\n\n\t\tif (i === pathSegments.length - 1) return acc;\n\n\t\tacc.push(i % 2 === 0 ? 'options' : 'values');\n\n\t\treturn acc;\n\t}, []);\n};\n"]}